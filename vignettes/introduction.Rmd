---
title: "Getting Started with mobspain"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with mobspain}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE  # Prevent actual data downloads during package build
)
```

```{r library}
library(mobspain)
library(dplyr)
library(sf)        # For spatial data manipulation and plotting
library(ggplot2)   # For advanced plotting
```

## Introduction

The `mobspain` package provides a comprehensive toolkit for analyzing Spanish mobility patterns using MITMA (Ministry of Transport, Mobility and Urban Agenda) data. This package is specifically designed for researchers and analysts users learning spatial data science concepts.

### Key Features

- **Automatic spatial mapping** of all analysis results using sf geometries
- **User-friendly workflow** with step-by-step messaging
- **Memory-optimized** processing with automatic data sampling
- **Advanced filtering capabilities** to reduce data download size
- **Complete spatial analysis** with choropleth maps, flow maps, and anomaly detection
- **Real government data** from Spanish Ministry of Transportation
- **Simplified functions** focusing on essential spatial analysis concepts

### About MITMA Data

The MITMA mobility data is derived from mobile phone analytics and provides origin-destination (OD) matrices representing population movements across Spain. Key characteristics:

- **Spatial Coverage**: Administrative levels available:
  - Districts (`dist`): ~3,909 zones (recommended for users)
  - Municipalities (`muni`): ~8,131 zones (detailed analysis)
  - Provinces (`prov`): ~52 zones (overview analysis)
- **Temporal Coverage**: Data available from February 14, 2020 onwards
- **Data Source**: Aggregated and anonymized mobile phone positioning data
- **Reference**: [MITMA Methodological Report](https://www.transportes.gob.es/recursos_mfom/paginabasica/recursos/a3_informe_metodologico_estudio_movilidad_mitms_v8.pdf)

## Quick Start

### Complete Analysis in One Function

For beginners, use the `quick_analysis()` function for a complete workflow:

```{r quick_start}
# Complete spatial analysis in one function
results <- quick_analysis(
  dates = "2023-01-01",  # Single day or date range
  level = "dist"         # District level analysis
)

# View spatial maps
print(results$maps$indicators)   # Mobility intensity map
print(results$maps$containment)  # Containment analysis map
print(results$maps$flows)        # Flow map showing major movements

# View summary statistics
print(results$summary)
```

### Regional Analysis (Recommended)

Use the new filtering capabilities to analyze specific regions:

```{r regional_analysis}
# Get both mobility data and spatial zones for Madrid
madrid_data <- get_region_mobility("Madrid", dates = "2023-01-01")

# Run analysis on Madrid data
madrid_indicators <- calc_indicators(madrid_data$mobility, madrid_data$zones)
print(madrid_indicators$map)

# Access data components
print(paste("Madrid zones:", nrow(madrid_data$zones)))
print(paste("Madrid mobility records:", nrow(madrid_data$mobility)))
```

## Data Access with Filtering

### Basic Data Access

```{r basic_access}
# Get mobility data (all zones - default behavior)
mobility_all <- get_mobility(dates = "2023-01-01", level = "dist")

# Get spatial zones (all zones - default behavior)
zones_all <- get_zones(level = "dist")

# Quick map of zones
plot(zones_all$geometry, main = "Spanish Districts")
```

### Advanced Filtering (NEW!)

The package now includes powerful filtering capabilities to reduce data download size:

```{r filtering_examples}
# 1. Filter by specific zones (Madrid and Barcelona districts)
madrid_barcelona_zones <- get_zones(
  level = "dist", 
  zones_filter = c("28079", "08019")  # Specific zone IDs
)

madrid_barcelona_mobility <- get_mobility(
  dates = "2023-01-01",
  level = "dist",
  zones_filter = c("28079", "08019")
)

# 2. Filter by region name
madrid_zones <- get_zones(level = "dist", region_filter = "Madrid")
madrid_mobility <- get_mobility(
  dates = "2023-01-01",
  level = "dist",
  region_filter = "Madrid"
)

# 3. Filter by province code (fastest option)
valencia_zones <- get_zones(level = "dist", region_filter = "46")
valencia_mobility <- get_mobility(
  dates = "2023-01-01",
  level = "dist",
  region_filter = "46"  # Valencia province code
)

# 4. Convenience function for regional analysis
barcelona_data <- get_region_mobility("Barcelona", dates = "2023-01-01")
# Access with: barcelona_data$mobility and barcelona_data$zones
```

### Memory Management

Control data size for memory-efficient processing:

```{r memory_management}
# Limit data size for memory-efficient processing
mobility_limited <- get_mobility(
  dates = "2023-01-01",
  level = "dist",
  region_filter = "Madrid",
  max_rows = 5000  # Automatic sampling if dataset is larger
)

# Check data size
cat("Downloaded", nrow(mobility_limited), "records\n")
cat("Memory usage:", format(object.size(mobility_limited), "MB"), "\n")
```

## Spatial Analysis

### Containment Analysis

Analyze how much people stay within their origin zones:

```{r containment_analysis}
# Calculate containment with spatial mapping
containment_result <- calculate_containment(
  mobility_data = madrid_mobility,
  spatial_zones = madrid_zones,
  create_map = TRUE
)

# View the spatial map
print(containment_result$map)

# View summary statistics
print(containment_result$summary)
```

### Anomaly Detection

Detect unusual mobility patterns:

```{r anomaly_detection}
# Detect anomalies with spatial mapping
anomaly_result <- detect_anomalies(
  mobility_data = madrid_mobility,
  spatial_zones = madrid_zones,
  threshold = 2.5  # Z-score threshold
)

# View anomaly map
print(anomaly_result$map)

# View anomaly summary
print(anomaly_result$summary)
```

### Flow Visualization

Create flow maps showing major movements:

```{r flow_maps_basic}
# Create flow map
flow_map <- create_flows(
  mobility_data = madrid_mobility,
  spatial_zones = madrid_zones,
  top_flows = 20  # Show top 20 flows
)

# View flow map
print(flow_map)
```

### Mobility Indicators

Calculate basic mobility indicators:

```{r mobility_indicators}
# Calculate mobility indicators
indicators <- calc_indicators(
  mobility_data = madrid_mobility,
  spatial_zones = madrid_zones
)

# View indicator map
print(indicators$map)

# View summary statistics
print(indicators$summary)
```

## Machine Learning Predictions

### Basic Predictions

Use machine learning to predict mobility patterns:

```{r ml_predictions}
# Simple ML prediction
predictions <- predict_patterns(
  mobility_data = madrid_mobility,
  prediction_dates = c("2023-01-08", "2023-01-09"),
  model_type = "linear_regression",
  spatial_zones = madrid_zones
)

# View prediction results
print(head(predictions$predictions))
print(predictions$spatial_map)
```

## Province Codes for Filtering

Common province codes for efficient filtering:

```{r province_codes}
# Major province codes
province_codes <- data.frame(
  code = c("28", "08", "46", "41", "29", "03", "48", "50", "35", "38"),
  name = c("Madrid", "Barcelona", "Valencia", "Sevilla", "Málaga", 
           "Alicante", "Bizkaia", "Zaragoza", "Las Palmas", "Tenerife")
)
print(province_codes)
```

## Comparing Regions

### Multi-Region Analysis

Compare mobility patterns between different regions:

```{r multi_region}
# Get data for multiple regions
madrid_data <- get_region_mobility("Madrid", dates = "2023-01-01")
valencia_data <- get_region_mobility("46", dates = "2023-01-01")  # Valencia province

# Calculate indicators for each region
madrid_indicators <- calc_indicators(madrid_data$mobility, madrid_data$zones)
valencia_indicators <- calc_indicators(valencia_data$mobility, valencia_data$zones)

# Compare summary statistics
cat("Madrid avg trips per zone:", round(madrid_indicators$summary$avg_trips_per_zone, 0), "\n")
cat("Valencia avg trips per zone:", round(valencia_indicators$summary$avg_trips_per_zone, 0), "\n")

# Compare containment levels
madrid_containment <- calculate_containment(madrid_data$mobility, madrid_data$zones)
valencia_containment <- calculate_containment(valencia_data$mobility, valencia_data$zones)

cat("Madrid avg containment:", round(madrid_containment$summary$avg_containment, 3), "\n")
cat("Valencia avg containment:", round(valencia_containment$summary$avg_containment, 3), "\n")
```

## Best Practices for Users

### 1. Start with Regional Filtering

```{r best_practices_1}
# Always start with regional filtering to manage data size
region_data <- get_region_mobility("Madrid")
```

### 2. Use Appropriate Spatial Level

```{r best_practices_2}
# For overview analysis (faster)
zones_overview <- get_zones(level = "dist")

# For detailed analysis (slower)
zones_detailed <- get_zones(level = "muni")
```

### 3. Limit Data Size

```{r best_practices_3}
# Limit data for memory-efficient processing
mobility <- get_mobility(
  region_filter = "Madrid",
  max_rows = 5000
)
```

### 4. Always Create Spatial Maps

```{r best_practices_4}
# All analysis functions automatically create maps
result <- calc_indicators(mobility, zones)
print(result$map)  # Always view the map!
```

### 5. Check Your Data

```{r best_practices_5}
# Always check what you downloaded
cat("Zones:", nrow(zones), "\n")
cat("Mobility records:", nrow(mobility), "\n")
cat("Date range:", range(mobility$date), "\n")
```

## Function Reference

### Data Access Functions

- `get_zones()` - Get administrative boundaries with filtering
- `get_mobility()` - Get mobility data with filtering
- `get_region_mobility()` - Get both mobility and zones for a region

### Analysis Functions

- `calc_indicators()` - Calculate basic mobility indicators
- `calculate_containment()` - Analyze spatial containment
- `detect_anomalies()` - Detect unusual patterns
- `predict_patterns()` - Machine learning predictions

### Visualization Functions

- `create_flows()` - Create flow maps
- `create_map()` - Create choropleth maps

### Workflow Functions

- `quick_analysis()` - Complete analysis in one function

## Getting Help

For help with any function, use:

```{r help}
?get_mobility
?get_zones
?get_region_mobility
?calc_indicators
?calculate_containment
?detect_anomalies
?create_flows
?quick_analysis

# Package-level help
?mobspain
```

## Next Steps

1. **Start with regional filtering** to manage data size
2. **Use the convenience function** `get_region_mobility()` for quick setup
3. **Always visualize results** with the automatic spatial maps
4. **Compare different regions** and time periods
5. **Explore different analysis parameters** (thresholds, model types, etc.)

This package provides a complete toolkit for spatial mobility analysis designed for researchers and analysts working with real-world mobility data. The filtering capabilities make it practical for memory-efficient processing while maintaining the full analytical power of the underlying MITMA data.
)  # Results: ~3,909 zones

# Get municipalities (standard administrative units)
municipalities <- get_spatial_zones(
  level = "muni",              # Municipality level
  version = 2
)  # Results: ~8,131 zones

# Get large urban areas (metropolitan areas)
large_urban_areas <- get_spatial_zones(
  level = "lua",               # Large Urban Areas level
  version = 2
)  # Results: ~85 zones

# Check the structure and contents of spatial data
print(paste("Districts loaded:", nrow(districts), "zones"))
print(paste("Columns available:", paste(names(districts), collapse = ", ")))
print(paste("Spatial zones with area data:", sum(!is.na(districts$area_km2))))

# Access key columns: districts$id, districts$name, districts$geometry, districts$area_km2
head(districts[, c("id", "name", "area_km2")])

# Plot zones using sf geometry
library(sf)
plot(st_geometry(districts), main = "Spanish Districts", col = "lightblue")

# Plot with data visualization
plot(districts["area_km2"], main = "District Areas (km²)")

# Basic map with ggplot2
library(ggplot2)
ggplot(districts) +
  geom_sf(aes(fill = area_km2)) +
  scale_fill_viridis_c(name = "Area (km²)") +
  labs(title = "Spanish Districts by Area") +
  theme_minimal()
```

### Mobility Data Retrieval

Get real mobility matrices from MITMA. The data represents aggregated trips between spatial zones:

```{r mobility_data}
# Get mobility data with available parameters
mobility_data <- get_mobility_matrix(
  dates = c("2023-01-01", "2023-01-07"),  # Date range (YYYY-MM-DD format)
  level = "dist",                          # Spatial level: "dist", "muni", "lua"
  time_window = NULL,                      # Time range: c(start_hour, end_hour), e.g., c(7, 9)
  aggregate_by = "none",                   # Aggregation: "none", "date", "hour"
  version = 2                              # Data version: 1 or 2
)
# Returns data.frame with columns: id_origin, id_destination, date, n_trips

# Get morning rush hour data (7-9 AM) for commuting analysis
commute_data <- get_mobility_matrix(
  dates = c("2023-03-01", "2023-03-07"), 
  level = "dist",
  time_window = c(7, 9),          # Morning commute hours (7 AM to 9 AM)
  version = 2
)

# Evening rush hour data (17-19 PM)
evening_data <- get_mobility_matrix(
  dates = c("2023-03-01", "2023-03-07"),
  level = "dist", 
  time_window = c(17, 19),        # Evening commute hours (5 PM to 7 PM)
  version = 2
)

# Weekend-only data for leisure analysis
weekend_data <- get_mobility_matrix(
  dates = c("2023-01-07", "2023-01-08"),  # Saturday-Sunday
  level = "muni",                          # Municipality level for faster processing
  version = 2
)

# Check data structure and key columns
cat("Mobility data structure:\n")
str(mobility_data)
cat("Key columns:", paste(names(mobility_data), collapse = ", "), "\n")
cat("Date range:", as.character(range(mobility_data$date)), "\n")
cat("Total rows:", nrow(mobility_data), "\n")
```

## Analytics

### Understanding MITMA Mobility Data

The mobility matrices represent estimated trips between zones based on mobile phone positioning:

```{r data_exploration}
# Examine the structure of mobility data with specific columns
print("Mobility data structure:")
print(head(mobility_data))
print("Column types:")
print(sapply(mobility_data, class))

# Validate data quality
quality_report <- validate_mitma_data(mobility_data)
print("Data quality summary:")
print(quality_report)
# Access results: quality_report contains validation statistics

# Check for Spanish holidays with specific parameters
holiday_check <- check_spanish_holidays(
  dates = unique(mobility_data$date),
  include_regional = TRUE,          # Include regional holidays
  buffer_days = 1                   # Check days around holidays
)
holidays_found <- holiday_check[holiday_check$is_likely_holiday, ]
if(nrow(holidays_found) > 0) {
  print("Holidays found in data period:")
  print(holidays_found[, c("date", "holiday_name", "holiday_type")])
}

# Comprehensive data coverage statistics
total_trips <- sum(mobility_data$n_trips, na.rm = TRUE)
unique_origins <- length(unique(mobility_data$id_origin))
unique_destinations <- length(unique(mobility_data$id_destination))
date_range <- range(mobility_data$date)
avg_daily_trips <- total_trips / length(unique(mobility_data$date))

print("Data coverage statistics:")
print(paste("Total trips recorded:", format(total_trips, big.mark = ",")))
print(paste("Unique origin zones:", unique_origins))
print(paste("Unique destination zones:", unique_destinations))
print(paste("Date range:", date_range[1], "to", date_range[2]))
print(paste("Average daily trips:", format(round(avg_daily_trips), big.mark = ",")))
```

### Containment Analysis

Self-containment measures the proportion of trips that stay within the same zone (internal mobility vs. external trips):

```{r containment}
# Calculate containment indices with specific parameters
containment <- calculate_containment(
  mobility_data,
  min_trips = 10,                   # Minimum trips threshold for inclusion
  normalize = TRUE,                 # Normalize by total trips
  include_totals = TRUE             # Include total trip counts
)
# Returns data.frame with: id_origin, containment, total_trips, internal_trips, external_trips

# Display most self-contained zones with specific sorting
print("Top 10 most self-contained zones:")
top_contained <- head(containment[order(-containment$containment), ], 10)
print(top_contained[, c("id_origin", "containment", "total_trips", "internal_trips")])

# Summary statistics with quantiles
containment_stats <- summary(containment$containment)
print("Containment index statistics:")
print(containment_stats)

# Additional analysis
high_containment <- sum(containment$containment > 0.5, na.rm = TRUE)
very_high_containment <- sum(containment$containment > 0.8, na.rm = TRUE)
print(paste("Zones with >50% containment:", high_containment))
print(paste("Zones with >80% containment:", very_high_containment))
print(paste("Mean containment index:", round(mean(containment$containment, na.rm = TRUE), 3)))
print(paste("Median containment index:", round(median(containment$containment, na.rm = TRUE), 3)))
```

### Advanced Mobility Indicators

Compute comprehensive mobility metrics including connectivity, flow balance, and spatial characteristics:

```{r indicators}
# Calculate comprehensive mobility indicators with parameters
indicators <- calculate_mobility_indicators(
  mobility_data, 
  districts,
  include_distance = TRUE,          # Include distance-based metrics
  normalize_by_population = FALSE,  # Normalize by population (if available)
  min_trips = 5,                    # Minimum trips threshold
  include_centrality = TRUE         # Include network centrality measures
)
# Returns data.frame with columns: id_origin, total_outflow, total_inflow, containment, 
# connectivity_index, net_flow, avg_distance, centrality_score

# Display key indicators with specific columns
print("Sample of mobility indicators:")
indicator_cols <- c("id_origin", "total_outflow", "total_inflow", "containment", 
                   "connectivity_index", "net_flow", "avg_distance")
print(head(indicators[, indicator_cols]))

# Analyze mobility patterns with detailed statistics
outflow_zones <- sum(indicators$net_flow < 0, na.rm = TRUE)
inflow_zones <- sum(indicators$net_flow > 0, na.rm = TRUE)
balanced_zones <- sum(abs(indicators$net_flow) < 100, na.rm = TRUE)

print("Mobility pattern analysis:")
print(paste("Zones with net outflow (job/service sources):", outflow_zones))
print(paste("Zones with net inflow (employment/service centers):", inflow_zones))
print(paste("Balanced zones (inflow ≈ outflow):", balanced_zones))

# Connectivity analysis
connectivity_stats <- summary(indicators$connectivity_index)
print("Connectivity index statistics:")
print(connectivity_stats)

# Distance analysis (if available)
if("avg_distance" %in% names(indicators)) {
  distance_stats <- summary(indicators$avg_distance)
  print("Average distance statistics (km):")
  print(distance_stats)
}
```

### Anomaly Detection

Detect unusual mobility patterns that deviate from normal behavior (useful for identifying special events, holidays, disruptions):

```{r anomalies}
# Detect anomalies with comprehensive parameters
anomalies <- detect_mobility_anomalies(
  mobility_data, 
  method = "zscore",                # Methods: "zscore", "iqr", "isolation"
  threshold = 2.5,                  # Z-score threshold (2.5 = 98.7th percentile)
  by_weekday = TRUE,                # Separate analysis by weekday/weekend
  min_trips = 100,                  # Minimum daily trips for analysis
  rolling_window = 7                # Rolling window for trend analysis
)
# Returns data.frame with: date, total_trips, z_score, is_anomaly, weekday, is_weekend

# Show detected anomalies with detailed information
print("Detected mobility anomalies:")
if(any(anomalies$is_anomaly)) {
  anomaly_dates <- anomalies[anomalies$is_anomaly, ]
  anomaly_cols <- c("date", "total_trips", "z_score", "is_anomaly", "weekday", "is_weekend")
  print(anomaly_dates[, anomaly_cols])
  
  # Statistical summary of anomalies
  print("Anomaly statistics:")
  print(paste("Total anomalies detected:", sum(anomalies$is_anomaly)))
  print(paste("Anomaly rate:", round(mean(anomalies$is_anomaly) * 100, 1), "%"))
  print(paste("Max z-score:", round(max(anomalies$z_score, na.rm = TRUE), 2)))
  print(paste("Min z-score:", round(min(anomalies$z_score, na.rm = TRUE), 2)))
  
  # Check if anomalies correspond to holidays
  anomaly_holidays <- check_spanish_holidays(
    dates = anomaly_dates$date,
    include_regional = TRUE
  )
  holiday_anomalies <- anomaly_holidays[anomaly_holidays$is_likely_holiday, ]
  
  if(nrow(holiday_anomalies) > 0) {
    print("Anomalies corresponding to holidays:")
    print(holiday_anomalies[, c("date", "holiday_name", "holiday_type")])
  }
} else {
  print("No significant anomalies detected in this period")
}

# Compare weekend vs weekday patterns with detailed analysis
print("Weekend vs Weekday mobility patterns:")
weekend_summary <- anomalies %>%
  dplyr::group_by(is_weekend) %>%
  dplyr::summarise(
    count = n(),
    avg_trips = mean(total_trips, na.rm = TRUE),
    median_trips = median(total_trips, na.rm = TRUE),
    anomaly_rate = mean(is_anomaly, na.rm = TRUE) * 100,
    avg_z_score = mean(abs(z_score), na.rm = TRUE),
    .groups = "drop"
  )
print(weekend_summary)
```

### Distance-Decay Modeling

Model how mobility flows decrease with distance (fundamental principle in spatial interaction modeling):

```{r distance_decay}
# Calculate distance-decay relationship with detailed parameters
decay_model <- calculate_distance_decay(
  mobility_data, 
  districts,
  max_distance = 500,               # Maximum distance in km
  distance_bins = 25,               # Distance bin size in km
  min_trips_per_bin = 50,           # Minimum trips per distance bin
  method = "power_law",             # Model type: "power_law", "exponential", "linear"
  weight_by_trips = TRUE            # Weight regression by trip volume
)
# Returns list with: model, r_squared, decay_exponent, coefficients, distance_bins, model_summary

# Display comprehensive model results
print("Distance-decay model summary:")
print(decay_model$model_summary)

# Key model statistics
print("Model performance metrics:")
print(paste("R-squared:", round(decay_model$r_squared, 3)))
print(paste("Distance decay exponent:", round(decay_model$decay_exponent, 3)))
print(paste("Model type:", decay_model$model_type))

# Access specific results
coefficients <- decay_model$coefficients
print("Model coefficients:")
print(coefficients)

# Interpretation guidelines
exponent <- decay_model$decay_exponent
print("Interpretation:")
if(abs(exponent) < 0.5) {
  print("Weak distance decay - mobility remains high over long distances")
} else if(abs(exponent) < 1.5) {
  print("Moderate distance decay - typical urban mobility pattern")
} else {
  print("Strong distance decay - highly localized mobility")
}

# Distance bin analysis
if("distance_bins" %in% names(decay_model)) {
  print("Distance bin statistics:")
  print(head(decay_model$distance_bins))
}
```

## Advanced Data Processing

### Direct spanishoddata Integration

The mobspain package is built on top of spanishoddata, giving you access to both high-level convenience functions and low-level data manipulation. You can use spanishoddata functions directly for advanced workflows:

```{r advanced_processing}
# Direct spanishoddata access for fine-grained control
library(spanishoddata)

# Get data using spanishoddata functions directly
od_20210407 <- spod_get("od", zones = "distr", dates = "2021-04-07")
districts_v1 <- spod_get_zones("dist", ver = 1)

# Preprocess data with dplyr
od_20210407_total <- od_20210407 |>
  group_by(origin = id_origin, dest = id_destination) |>
  summarise(count = sum(n_trips, na.rm = TRUE), .groups = "drop") |> 
  collect()

# Time-series data with hourly resolution
od_20210407_time <- od_20210407 |>
  mutate(time = as.POSIXct(paste0(date, "T", hour, ":00:00"))) |>
  group_by(origin = id_origin, dest = id_destination, time) |>
  summarise(count = sum(n_trips, na.rm = TRUE), .groups = "drop") |> 
  collect()

# Calculate centroids for all districts
districts_v1_centroids <- districts_v1 |>
  st_transform(4326) |> 
  st_centroid() |>
  st_coordinates() |>
  as.data.frame() |>
  mutate(id = districts_v1$id) |>
  rename(lon = X, lat = Y)

# Filter Madrid districts
zones_madrid <- districts_v1 |>
  filter(grepl("Madrid", name, ignore.case = TRUE))

# Create functional urban area buffer around Madrid
zones_madrid_fua <- districts_v1[
  st_buffer(zones_madrid, dist = 10000),
]

# Centroids for Madrid FUA
zones_madrid_fua_coords <- zones_madrid_fua |>
  st_transform(crs = 4326) |>
  st_centroid() |>
  st_coordinates() |>
  as.data.frame() |>
  mutate(id = zones_madrid_fua$id) |>
  rename(lon = X, lat = Y)

# Filter flows for Madrid FUA
od_20210407_total_madrid <- od_20210407_total |>
  filter(origin %in% zones_madrid_fua$id & dest %in% zones_madrid_fua$id)

# Filter time-series flows for Madrid FUA
od_20210407_time_madrid <- od_20210407_time |>
  filter(origin %in% zones_madrid_fua$id & dest %in% zones_madrid_fua$id) |>
  filter(count > 50)  # Filter small flows for better visualization

print("Advanced data processing completed:")
print(paste("Total OD pairs:", nrow(od_20210407_total)))
print(paste("Madrid FUA zones:", nrow(zones_madrid_fua)))
print(paste("Madrid FUA flows:", nrow(od_20210407_total_madrid)))
```

### Custom Mobility Heatmap

Create advanced visualizations using processed data:

```{r custom_heatmap}
# Calculate flow totals for Madrid
flow_totals <- bind_rows(
  od_20210407_total_madrid |> 
    group_by(id = origin) |> 
    summarise(out_flows = sum(count, na.rm = TRUE)),
  od_20210407_total_madrid |> 
    group_by(id = dest) |> 
    summarise(in_flows = sum(count, na.rm = TRUE))
) |>
  group_by(id) |>
  summarise(
    out_flows = sum(out_flows, na.rm = TRUE),
    in_flows = sum(in_flows, na.rm = TRUE),
    total_flows = out_flows + in_flows,
    .groups = "drop"
  )

# Join with spatial data
madrid_activity <- zones_madrid_fua |>
  left_join(flow_totals, by = "id") |>
  st_as_sf()

# Create mobility heatmap
library(scales)
library(ggspatial)

mobility_heatmap <- ggplot(madrid_activity) +
  geom_sf(aes(fill = total_flows), color = "white", linewidth = 0.3) +
  geom_sf(data = zones_madrid, fill = NA, color = "cyan", linewidth = 0.8) +
  scale_fill_viridis_c(
    option = "inferno", 
    name = "Total Trips", 
    trans = "log10", 
    breaks = c(100, 500, 2500, 10000, 50000),
    labels = label_comma(),
    na.value = "grey90"
  ) +
  labs(
    title = "Mobility Intensity in Madrid Functional Urban Area",
    subtitle = "Total trips (incoming + outgoing) on April 7, 2021",
    caption = "Data: Spanish Ministry of Transport | Cyan outline: Madrid city districts"
  ) +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
    plot.subtitle = element_text(color = "grey30", size = 12, hjust = 0.5),
    plot.caption = element_text(color = "grey50", size = 9),
    panel.background = element_rect(fill = "white", color = NA),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8)
  ) +
  annotation_scale(location = "br", width_hint = 0.25) +
  annotation_north_arrow(location = "tr", style = north_arrow_minimal())

print(mobility_heatmap)

# Calculate and display summary statistics
madrid_stats <- madrid_activity |>
  st_drop_geometry() |>
  summarise(
    zones = n(),
    total_trips = sum(total_flows, na.rm = TRUE),
    avg_trips_per_zone = mean(total_flows, na.rm = TRUE),
    median_trips = median(total_flows, na.rm = TRUE),
    max_trips = max(total_flows, na.rm = TRUE),
    .groups = "drop"
  )

print("Madrid FUA Mobility Statistics:")
print(madrid_stats)
```

### Temporal Analysis

Analyze mobility patterns over time using the time-series data:

```{r temporal_analysis}
# Hourly mobility patterns for Madrid FUA
hourly_patterns <- od_20210407_time_madrid |>
  mutate(hour = as.numeric(format(time, "%H"))) |>
  group_by(hour) |>
  summarise(
    total_trips = sum(count, na.rm = TRUE),
    unique_flows = n(),
    avg_flow_size = mean(count, na.rm = TRUE),
    .groups = "drop"
  )

# Create hourly pattern plot
hourly_plot <- ggplot(hourly_patterns, aes(x = hour, y = total_trips)) +
  geom_line(color = "steelblue", size = 1.2) +
  geom_point(color = "darkblue", size = 2) +
  scale_x_continuous(breaks = seq(0, 23, 2), labels = paste0(seq(0, 23, 2), ":00")) +
  scale_y_continuous(labels = label_comma()) +
  labs(
    title = "Hourly Mobility Patterns in Madrid FUA",
    subtitle = "April 7, 2021 (Wednesday)",
    x = "Hour of Day",
    y = "Total Trips",
    caption = "Data: Spanish Ministry of Transport"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(color = "grey30", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.minor = element_blank()
  )

print(hourly_plot)

# Identify peak hours
peak_hours <- hourly_patterns |>
  arrange(desc(total_trips)) |>
  head(3)

print("Peak mobility hours:")
print(peak_hours)
```

### Network Analysis

Analyze the mobility network structure:

```{r network_analysis}
# Create network metrics for Madrid FUA
library(igraph)

# Prepare edge list for network analysis
edge_list <- od_20210407_total_madrid |>
  filter(count > 100) |>  # Focus on significant flows
  select(from = origin, to = dest, weight = count)

# Create igraph object
mobility_network <- graph_from_data_frame(edge_list, directed = TRUE)

# Calculate network metrics
network_metrics <- data.frame(
  node = V(mobility_network)$name,
  degree = degree(mobility_network),
  in_degree = degree(mobility_network, mode = "in"),
  out_degree = degree(mobility_network, mode = "out"),
  betweenness = betweenness(mobility_network),
  closeness = closeness(mobility_network),
  page_rank = page_rank(mobility_network)$vector
) |>
  arrange(desc(page_rank))

# Join with spatial data for visualization
network_zones <- zones_madrid_fua |>
  left_join(network_metrics, by = c("id" = "node"))

# Create network centrality map
centrality_map <- ggplot(network_zones) +
  geom_sf(aes(fill = page_rank), color = "white", linewidth = 0.2) +
  geom_sf(data = zones_madrid, fill = NA, color = "red", linewidth = 0.8) +
  scale_fill_viridis_c(
    name = "PageRank\nCentrality",
    option = "plasma",
    na.value = "grey90"
  ) +
  labs(
    title = "Mobility Network Centrality in Madrid FUA",
    subtitle = "PageRank centrality based on mobility flows",
    caption = "Higher values indicate more central zones in mobility network"
  ) +
  theme_void() +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 14, hjust = 0.5),
    plot.subtitle = element_text(color = "grey30", size = 11, hjust = 0.5)
  )

print(centrality_map)

# Display top central zones
print("Top 10 most central zones by PageRank:")
print(head(network_metrics[, c("node", "page_rank", "degree")], 10))
```

## Visualization

### Plotting Spatial Zones

The spatial zones are `sf` objects that can be plotted using multiple approaches:

```{r plot_zones}
# Basic geometry plotting with sf
library(sf)
library(ggplot2)

# Simple boundary plot
plot(st_geometry(districts), main = "Spanish Districts", 
     col = "lightblue", border = "darkblue")

# Plot with data attributes
plot(districts["area_km2"], main = "District Areas (km²)")

# Population density (if available)
if("population" %in% names(districts) && "area_km2" %in% names(districts)) {
  districts$pop_density <- districts$population / districts$area_km2
  plot(districts["pop_density"], main = "Population Density (per km²)")
}

# Advanced ggplot2 visualization
zone_plot <- ggplot(districts) +
  geom_sf(aes(fill = area_km2), color = "white", size = 0.1) +
  scale_fill_viridis_c(name = "Area\n(km²)", trans = "log10") +
  labs(title = "Spanish Districts by Area", 
       subtitle = "Administrative boundaries for mobility analysis") +
  theme_void() +
  theme(legend.position = "bottom")
print(zone_plot)

# Focus on specific regions (e.g., Madrid area)
madrid_zones <- districts[grepl("Madrid", districts$name, ignore.case = TRUE), ]
if(nrow(madrid_zones) > 0) {
  madrid_plot <- ggplot(madrid_zones) +
    geom_sf(aes(fill = area_km2), color = "white") +
    scale_fill_viridis_c(name = "Area (km²)") +
    labs(title = "Madrid Districts") +
    theme_void()
  print(madrid_plot)
}

# Interactive plotting with leaflet
library(leaflet)
leaflet(districts[1:50, ]) %>%  # First 50 zones for performance
  addTiles() %>%
  addPolygons(
    fillColor = ~colorQuantile("YlOrRd", area_km2)(area_km2),
    weight = 1,
    opacity = 1,
    color = "white",
    dashArray = "3",
    fillOpacity = 0.7,
    popup = ~paste("Zone:", name, "<br>Area:", round(area_km2, 1), "km²")
  )
```

### Time Series Plots

Visualize mobility trends over time:

```{r daily_mobility}
# Create daily mobility plot with styling options
daily_plot <- plot_daily_mobility(
  mobility_data,
  group_by = "weekday",            # Options: "weekday", "date", "none"
  smooth = TRUE,                   # Add trend line
  color_by = "day_type",           # Color by weekend/weekday
  title = "Daily Mobility Patterns",
  y_axis_label = "Total Trips",
  date_labels = "%b %d"            # Date format
)
print(daily_plot)

# Alternative: Simple time series plot
simple_plot <- plot_daily_mobility(
  mobility_data,
  group_by = "date",
  smooth = FALSE
)
print(simple_plot)
```

### Interactive Flow Maps

Create interactive maps of mobility flows:

```{r flow_maps_interactive}
# Create interactive flow map with comprehensive styling
flow_map <- create_flow_map(
  districts, 
  mobility_data, 
  min_flow = 500,                  # Minimum flow threshold
  max_flows = 100,                 # Maximum number of flows to display
  line_color = "blue",             # Flow line color
  line_width_scale = 1.5,          # Line width scaling factor
  line_opacity = 0.7,              # Line transparency (0-1)
  background_map = "cartodb",      # Options: "osm", "cartodb", "stamen"
  zoom_level = 6,                  # Initial zoom level
  cluster_origins = TRUE           # Cluster origin points
)
# Returns leaflet map object
flow_map

# Alternative: Simple flow map
simple_flow_map <- create_flow_map(
  districts, 
  mobility_data, 
  min_flow = 1000,
  background_map = "osm"
)
simple_flow_map
```

### Choropleth Maps

Create maps showing spatial indicators:

```{r choropleth}
# Create choropleth map with detailed styling options
choropleth <- create_choropleth_map(
  districts, 
  indicators, 
  variable = "containment",         # Column name to visualize
  color_palette = "viridis",        # Options: "viridis", "plasma", "blues", "reds"
  legend_title = "Self-containment Index",
  breaks = 5,                       # Number of color breaks
  na_color = "grey",                # Color for missing values
  border_color = "white",           # Zone border color
  border_weight = 0.5,              # Border line weight
  popup_columns = c("name", "containment", "total_trips")  # Popup information
)
# Returns leaflet map object
choropleth

# Alternative: Different variable and styling
connectivity_map <- create_choropleth_map(
  districts,
  indicators,
  variable = "connectivity_index",
  color_palette = "plasma",
  legend_title = "Connectivity Index",
  breaks = 7
)
connectivity_map
```

### Heatmaps

Create flow matrix heatmaps:

```{r heatmaps}
# Create mobility heatmap with styling parameters
heatmap <- plot_mobility_heatmap(
  mobility_data, 
  top_n = 20,                      # Top N zones to include
  cluster_rows = TRUE,             # Cluster similar zones
  cluster_cols = TRUE,             # Cluster similar time periods
  color_scale = "log10",           # Options: "linear", "log10", "sqrt"
  color_palette = "viridis",       # Color palette
  show_values = FALSE,             # Show numeric values in cells
  title = "Mobility Flow Heatmap",
  x_axis_label = "Destination Zones",
  y_axis_label = "Origin Zones"
)
print(heatmap)

# Alternative: Simple heatmap with different parameters
simple_heatmap <- plot_mobility_heatmap(
  mobility_data,
  top_n = 15,
  cluster_rows = FALSE,
  color_scale = "linear",
  color_palette = "blues"
)
print(simple_heatmap)
```

### Distance-Decay Plots

Visualize distance-decay relationships:

```{r distance_plots}
# Create distance-decay visualization with styling options
decay_plot <- plot_distance_decay(
  decay_model,
  point_color = "blue",            # Data point color
  line_color = "red",              # Regression line color
  point_size = 2,                  # Point size
  line_width = 1.5,                # Line width
  add_r_squared = TRUE,            # Show R-squared on plot
  log_scale = TRUE,                # Use log scale for axes
  title = "Distance-Decay Relationship",
  x_axis_label = "Distance (km)",
  y_axis_label = "Trip Frequency"
)
print(decay_plot)

# Alternative: Linear scale plot
linear_plot <- plot_distance_decay(
  decay_model,
  log_scale = FALSE,
  point_color = "darkgreen",
  line_color = "orange"
)
print(linear_plot)
```

## Configuration

The package supports advanced configuration:

```{r config}
# Configure package with comprehensive options
configure_mobspain(
  parallel = TRUE,                  # Enable parallel processing
  n_cores = 4,                      # Number of CPU cores
  max_cache_size = 1000             # Cache size in MB
)

# Check detailed configuration status
status <- mobspain_status()
print("Package configuration:")
print(status)
# Access specific settings: status$parallel, status$cache_enabled, status$data_dir

# Note: Cache management functions may vary by implementation
# Check available cache functions with: ls("package:mobspain")
if(exists("cleanup_cache")) {
  cleanup_cache(max_age_days = 30)
}
```

## Conclusion

The `mobspain` package provides a complete toolkit for Spanish mobility analysis, from data retrieval to advanced analytics and visualization. 

### Key Methodological Notes

When working with MITMA data, consider:

- **Data Quality**: Mobile phone data represents a sample of the population; results should be interpreted as relative patterns rather than absolute counts
- **Temporal Patterns**: Weekdays vs. weekends show different mobility patterns; holidays and special events may create anomalies
- **Spatial Resolution**: District-level data provides fine detail but requires more computational resources; municipality or LUA levels may be more appropriate for regional studies
- **Privacy Protection**: All data is aggregated and anonymized according to Spanish data protection standards

### Plotting and Visualization Options

The package provides multiple ways to visualize spatial data:

- **Basic sf plotting**: Use `plot(st_geometry(zones))` for simple boundary maps
- **Data visualization**: Use `plot(zones["variable"])` to show spatial patterns
- **ggplot2 integration**: Create publication-quality maps with `geom_sf()`
- **Interactive maps**: Use built-in leaflet functions or create custom interactive maps
- **Statistical plots**: Time series, heatmaps, and decay plots for analytical visualization

All spatial zones are standard `sf` objects compatible with the broader R spatial ecosystem.

### Further Resources

- **MITMA Methodology**: [Official methodological report](https://www.transportes.gob.es/recursos_mfom/paginabasica/recursos/a3_informe_metodologico_estudio_movilidad_mitms_v8.pdf)
- **Package Documentation**: `?mobspain` or `help(package = "mobspain")`
- **Example Scripts**: See `basic_example.R`, `advanced_example.R`, and `spanishoddata_example.R` in the package repository

For more information, see the package documentation and example scripts.
